#!/usr/bin/perl -w
# ppp
# external script for traffic shapping
#
#-------------------------------------------------------------
# /etc/ppp/ppp.linkup
#
# MYADDR:
# !bg /usr/abills/libexec/linkupdown up INTERFACE USER HISADDR
#
# /etc/ppp/ppp.linkdown
#
# MYADDR:
# !bg /usr/abills/libexec/linkupdown down INTERFACE USER HISADDR
#
#-------------------------------------------------------------
# /usr/local/etc/mpd/mpd.conf
#
# set iface up-script "/usr/abills/libexec/linkupdown mpd up"
# set iface down-script "/usr/abills/libexec/linkupdown mpd down"
#-------------------------------------------------------------
# For Linux
# 
# Add to /etc/ppp/ip-up.local 
# /usr/abills/libexec/linkupdown pppd up $1 'username' $4
#
# Add to /etc/ppp/ip-down.local 
# /usr/abills/libexec/linkupdown pppd down $1 'username' $4
#
# IPN Linux:
# /usr/local/bin/sudo /usr/abills/libexec/linkupdown ipn up eth0 %LOGIN %IP
# /usr/local/bin/sudo /usr/abills/libexec/linkupdown ipn down eth0 %LOGIN %IP
#
# IPN FreeBSD
# /usr/local/bin/sudo /usr/abills/libexec/linkupdown ipn up fxp0 %LOGIN %IP
# /usr/local/bin/sudo /usr/abills/libexec/linkupdown ipn down fxp0 %LOGIN %IP
# 
#




my $debug=0;

$debug=1 if ($#ARGV > -1 && $ARGV[$#ARGV] eq 'debug');

#If not anought arguments
if ( $#ARGV < 3 ) {
 print qq{Not anought argumets:
 Example:
----------------------------------------------------------------
For IPN
  \$conf{IPN_FW_START_RULE}="/usr/abills/libexec/linkupdown ipn up INTERFACE %LOGIN% %IP%";
  \$conf{IPN_FW_STOP_RULE}="/usr/abills/libexec/linkupdown ipn down INTERFACE %LOGIN% %IP%";

----------------------------------------------------------------
 /etc/ppp/ppp.linkup
 MYADDR:
   !bg /usr/abills/libexec/linkupdown up INTERFACE USER HISADDR

 /etc/ppp/ppp.linkdown
 MYADDR:
   !bg /usr/abills/libexec/linkupdown down INTERFACE USER HISADDR

----------------------------------------------------------------
 /usr/local/etc/mpd/mpd.conf
   set iface up-script "/usr/abills/libexec/linkupdown mpd up"
   set iface down-script "/usr/abills/libexec/linkupdown mpd down"
----------------------------------------------------------------
 For Linux:
 (Work only with user static IP address)
 Add to /etc/ppp/ip-up.local 
   /usr/abills/libexec/linkupdown pppd up \$1 'username' \$4

 Add to /etc/ppp/ip-down.local 
   /usr/abills/libexec/linkupdown pppd down \$1 'username' \$4
 
 For mikrotik (use it as acct external cmd /usr/abills/libexec/acct_ext):
 
  /usr/abills/libexec/linkupdown mikrotik up INTERFACE USER HISADD NAS_HOST=192.168.1.1 NAS_ADMIN=admin [SSH_CMD=.., debug]
  /usr/abills/libexec/linkupdown mikrotik down INTERFACE USER HISADD NAS_HOST=192.168.1.1 NAS_ADMIN=admin [SSH_CMD=.., debug]

DEBUG: $debug
};
exit 0;
}


use vars  qw(%RAD %conf $db @START_FW);
use strict;

use FindBin '$Bin';
require $Bin . '/config.pl';
#use lib '../', "../Abills/$conf{dbtype}";
unshift(@INC, $Bin . '/../', $Bin ."/../Abills/$conf{dbtype}");
require Abills::Base;
Abills::Base->import();
my $begin_time = check_time();

require Abills::SQL;
my $sql = Abills::SQL->connect($conf{dbtype}, "$conf{dbhost}", $conf{dbname}, $conf{dbuser}, $conf{dbpasswd});
my $db = $sql->{db};
my $OS = '';


print "$ARGV[$#ARGV-1]\n";
if  ($ARGV[$#ARGV-1] =~ /^OS=(\S+)/ || $ARGV[$#ARGV] =~ /^OS=(\S+)/ ){
  $OS=$1;
}


require Billing;
Billing->import();
my $Billing = Billing->new($db, \%conf);



my $CLIENT_IP = 'any';
my $fw_step = 1000;


my $IPFW='/sbin/ipfw';
#my @START_FW = (3000, 2000, 1000);

# Arguments
my ($ACTION, $INTERFACE, $USER, $HISADDR, $inum);

#MPD
if ($ARGV[0] eq 'mpd') {
  $ACTION   = $ARGV[1];
  $INTERFACE= $ARGV[2];
  $USER     = $ARGV[6];
  $HISADDR  = $ARGV[5];
  $inum     = $INTERFACE;
  $inum     =~ s/ng//;
}
#OpenVPN
elsif ($ARGV[0] eq 'openvpn') {
  $ACTION    = $ARGV[1];
  $INTERFACE = $ARGV[2];
  $USER      = $ARGV[6];
  $HISADDR   = $ARGV[5];
  $inum      = (! ($INTERFACE =~ s/tap//)) ? 100+8 : $INTERFACE+100;
} 
elsif ($ARGV[0] eq 'ipn') {
  $ACTION    = $ARGV[1];
  $INTERFACE = $ARGV[2];
  $USER      = $ARGV[3];
  $HISADDR   = $ARGV[4];
  $CLIENT_IP = $HISADDR;	
	my ($n1, $n2, $n3, $n4) = split(/\./, $HISADDR, 4);
  $inum  = $n4;

  if ($INTERFACE eq 'getif') {
    $INTERFACE = `/sbin/route -n get $HISADDR | /usr/bin/grep interface: | /usr/bin/awk '{print \$2}'`;
   }

  if ($INTERFACE =~ /eth/) {
  	$OS = 'Linux';
   }


}
elsif($ARGV[0] eq 'pppd' || $ARGV[0] eq 'mikrotik') {
  $ACTION   = $ARGV[1];
  $INTERFACE= $ARGV[2];
  $USER     = $ARGV[3];
  $HISADDR  = $ARGV[4];
  $inum     = $INTERFACE;
  if(! ($inum =~ s/ppp//)) {
  	$inum = 0;
   }
  $OS = 'Linux';

 }
# FreeBSD PPP
else {
  $ACTION    = $ARGV[0];
  $INTERFACE = $ARGV[1];
  $USER      = $ARGV[2];
  $HISADDR   = $ARGV[3];
  $inum      = $INTERFACE;
  $inum      =~ s/tun//;
} 


$INTERFACE=~s/\n//;
my $via_if_in  = ($INTERFACE ne '-') ? "via $INTERFACE in" : '';
my $via_if_out = ($INTERFACE ne '-') ? "via $INTERFACE out" : '';

require Admins;
Admins->import();
require Dv;
Dv->import();


my $admin = Admins->new($db, \%conf);
$admin->info($conf{SYSTEM_ADMIN_ID}, { IP => '127.0.0.1' });
my $Dv = Dv->new($db, $admin, \%conf); 

my %LIST_PARAMS = ();
my @FW_ACTIONS  = ();


# Flush rules
  my($fw_num, $pipe_num, $fw_nums, $pipe_nums);

  my $user = undef;
  
  if ($ARGV[0] eq 'ipn') {
    if ($conf{IPN_FW_RULE_UID}) {
      $user = $Dv->info(0, { LOGIN => $USER });
      $inum = $user->{UID};
     }
    $conf{IPN_FW_FIRST_RULE}=20000 if (! $conf{IPN_FW_FIRST_RULE});

    $START_FW[0]=$START_FW[0]+$conf{IPN_FW_FIRST_RULE};
    $START_FW[1]=$START_FW[1]+$conf{IPN_FW_FIRST_RULE};
    $START_FW[2]=$START_FW[2]+$conf{IPN_FW_FIRST_RULE};
   }

  foreach my $num (@START_FW) {
    $fw_num     = $num + $inum * 2;
    $pipe_num   = $num + $inum * 2;
    $fw_nums   .= ' ' . ($fw_num)   .' '. ($fw_num +1);
    $pipe_nums .= ' ' . ($pipe_num) .' '. ($pipe_num+1);
   }




if ($ARGV[0] eq 'pppd') {
	#push @FW_ACTIONS, "/sbin/tc qdisk del dev $INTERFACE";
	$LIST_PARAMS{IP}=$HISADDR;
 } 
else {
  if ($OS eq 'Linux') {
   }
  else {
    push @FW_ACTIONS, "$IPFW -f delete $fw_nums";
    #push @FW_ACTIONS, "$IPFW -f pipe delete $pipe_nums";
   }
  $LIST_PARAMS{LOGIN} = "$USER";
}

# Up fw shaper rules
if ($ACTION eq 'up' || $OS eq 'Linux') {
  my %speeds = ();
  my %nets   = ();
  my %expr   = ();
  
  if (! defined($user)) {
    $user = $Dv->info(0, { %LIST_PARAMS });
   }

  if(defined($Dv->{errno})) {
     print "Error: User not exist ([$Dv->{errno}] $Dv->{errstr})\n";
     exit 1;
   }
  elsif($Dv->{TOTAL} < 1) {
    print "$USER - Not exist\n";
    exit 1;
   }
 


  #JOIN Service
  $conf{JOIN_SERVICE_FW_FIRST_RULE} = 40000 if (! $conf{JOIN_SERVICE_FW_FIRST_RULE});


  if ($user->{JOIN_SERVICE}) {
 	  if ($user->{JOIN_SERVICE} > 1) {
  	  $user = $Dv->info($user->{JOIN_SERVICE});
     }   

    $user->{JOIN_SERVICE}=$user->{UID}	
  }

  if ($user->{SPEED} > 0) {
    $speeds{0}{IN} = int($user->{SPEED});
    $speeds{0}{OUT}= int($user->{SPEED});
   }
  else {

    ($user->{TIME_INTERVALS},
     $user->{INTERVAL_TIME_TARIF}, 
     $user->{INTERVAL_TRAF_TARIF}) = $Billing->time_intervals($user->{TP_ID});

    my ($remaining_time, $ret_attr) = $Billing->remaining_time($user->{DEPOSIT}, {
    	    TIME_INTERVALS      => $user->{TIME_INTERVALS},
          INTERVAL_TIME_TARIF => $user->{INTERVAL_TIME_TARIF},
          INTERVAL_TRAF_TARIF => $user->{INTERVAL_TRAF_TARIF},
          SESSION_START       => $user->{SESSION_START},
          DAY_BEGIN           => $user->{DAY_BEGIN},
          DAY_OF_WEEK         => $user->{DAY_OF_WEEK},
          DAY_OF_YEAR         => $user->{DAY_OF_YEAR},
          REDUCTION           => $user->{REDUCTION},
          POSTPAID            => 1,
          GET_INTERVAL        => 1,
          debug               => ($debug > 0) ? 1 : undef
         });

#    print "RT: $remaining_time\n"  if ($debug == 1);
    my %TT_IDS = %$ret_attr;


    if (keys %TT_IDS > 0) {
    	
      require Tariffs;
      Tariffs->import();
      my $tariffs = Tariffs->new($db, \%conf, $admin);

      #Get intervals
      while(my($k, $v)=each( %TT_IDS)) {
        print "$k, $v\n" if ($debug > 0);

        next if ($k ne 'FIRST_INTERVAL');

        $user->{TI_ID}=$v;
 	      my $list = $tariffs->tt_list({ TI_ID => $v });
 	      foreach my $line (@$list)  {
 	    	  $speeds{$line->[0]}{IN}="$line->[4]";
 	    	  $speeds{$line->[0]}{OUT}="$line->[5]";
 	    	  $nets{$line->[0]}="$line->[7]";
 	    	  $expr{$line->[0]}="$line->[8]" if (length($line->[8]) > 5);
 	    	  #print "$line->[0] $line->[4]\n";
 	      }
      }
    }
  
   }

 # speed apply
  my $fw_num_in    =0;
  my $fw_num_out   =0;
  my $pipe_num_in  =0;
  my $pipe_num_out =0;
  
  
print "Expresion:================================\n" if ($debug > 0);
  my $RESULT = $Billing->expression($Dv->{UID}, \%expr, { START_PERIOD => $Dv->{ACCOUNT_ACTIVATE}, 
  	                                                      debug        => $debug } );
print "\nEND: =====================================\n" if ($debug > 0);

  if (! $RESULT->{SPEED}) {
    $speeds{0}{IN}=$RESULT->{SPEED_IN} if($RESULT->{SPEED_IN});
    $speeds{0}{OUT}=$RESULT->{SPEED_OUT} if($RESULT->{SPEED_OUT});
   }
  else {
  	$speeds{0}{IN}=$RESULT->{SPEED};
  	$speeds{0}{OUT}=$RESULT->{SPEED};
   }



  if ($ARGV[0] eq 'mikrotik') {
    mikrotik_ext({ SPEEDS => \%speeds,
    	         NETS   => \%nets });
    	         
  	exit;
   }
  
  #Make speed rules
  foreach my $traf_type (sort keys %speeds) {
    my $speed = $speeds{$traf_type};

    if (! $START_FW[$traf_type]) {
       $START_FW[$traf_type]=$START_FW[0]+$traf_type*$fw_step;
     }

    $fw_num_in    = $START_FW[$traf_type] + $inum * 2;
    $fw_num_out   = $START_FW[$traf_type] + $inum * 2 + 1;

    if ($user->{JOIN_SERVICE}) {
      $pipe_num_in = $conf{JOIN_SERVICE_FW_FIRST_RULE} + $user->{JOIN_SERVICE} * 2 + $traf_type * $fw_step;
      $pipe_num_out = $conf{JOIN_SERVICE_FW_FIRST_RULE} + $user->{JOIN_SERVICE} * 2 + 1 + $traf_type * $fw_step ;
     }
    else {
      $pipe_num_in  = $START_FW[$traf_type] + $inum * 2 ;
      $pipe_num_out = $START_FW[$traf_type] + $inum * 2 + 1;
     }

    my $speed_in  = (defined($speed->{IN}))  ? $speed->{IN}  : 0;
    my $speed_out = (defined($speed->{OUT})) ? $speed->{OUT} : 0;

 	  my @nets_arr = ();
 	  if ($nets{$traf_type}) {
 	    $nets{$traf_type} =~ s/[\r]?\n//g;
 	    $nets{$traf_type} =~ s/;/,/g;
 	    @nets_arr = split(/;|,/, $nets{$traf_type});
	   }

    @nets_arr = ('0.0.0.0/0') if ($#nets_arr < 0);

    #Mikrotik shaper
    if ($ARGV[0] eq 'mikrotik' ) {
    	mikrotik_ext({ 
    		  SPEED_IN  => $speed_in,
    		  SPEED_OUT => $speed_out,
    		  NETS_ID   => undef,
    		  NETS      => \@nets_arr 
    		 });
     }
    #Linux shaper

    elsif ($OS eq 'Linux') {

      my $tc = "/sbin/tc";
      my $flowid = $speed_in > 0 ? sprintf("%x",$fw_num_out) : '';
      my $drop = $speed_out > 0 ? "police rate $speed_out"."Kibit burst 12k drop" : '';


      push @FW_ACTIONS, "$tc filter del dev $INTERFACE protocol ip parent 1: prio $fw_num_out &>/dev/null";
      push @FW_ACTIONS, "$tc filter del dev $INTERFACE protocol ip parent ffff: prio $fw_num_in &>/dev/null";

      if ($flowid) {
        push @FW_ACTIONS, "$tc class del dev $INTERFACE parent 1: classid 1:$flowid &>/dev/null";
        if ($ACTION eq 'up') {
          push @FW_ACTIONS, "$tc class add dev $INTERFACE parent 1: classid 1:$flowid htb rate $speed_in"."Kibit";
         }
       }
 
      if ($ACTION eq 'up') {
        foreach my $ip_full (@nets_arr) {
                                if ($ip_full =~ /([!]{0,1})(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\/{0,1}(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|\d{1,2}):{0,1}(\S{0,200})/ ) {
#                      if (@nets_arr) {
#                              foreach my $ip_full (@nets_arr) {
#                                      if ($ip_full =~ /([!]{0,1})(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\/{0,1}(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}|\d{1,2}):{0,1}(\S{0,200})/ ) {
#                                              push @FW_ACTIONS, "$tc filter $act dev $INTERFACE protocol ip parent ffff: prio $prio match ip src $CLIENT_IP/32 match ip dst $2/$3 police rate $speed_out"."Kibit burst 12k drop flowid :1";
#                               }
#                               }
#                       }
#                      else {
#                              push @FW_ACTIONS, "$tc filter $act dev $INTERFACE protocol ip parent ffff: prio $prio match ip src $CLIENT_IP/32 police rate $speed_out"."Kibit burst 12k drop flowid :1";
#                      }
             push @FW_ACTIONS, "$tc filter add dev $INTERFACE protocol ip parent 1: prio $fw_num_out u32 match ip src $2/$3 match ip dst $CLIENT_IP flowid 1:$flowid";
             push @FW_ACTIONS, "$tc filter add dev $INTERFACE protocol ip parent ffff: prio $fw_num_in u32 match ip src $CLIENT_IP match ip dst $2/$3 $drop flowid 1:";
            }
         }
      }
   }


    #FreeBSD ipfw pipe shaper
    else {
     if ($speed_in > 0) {
    	  #In;
        if ($traf_type == 0) {
          # In
          push @FW_ACTIONS, "$IPFW add $fw_num_in pipe $pipe_num_in ip from $CLIENT_IP to any $via_if_in";
          push @FW_ACTIONS, "$IPFW pipe $pipe_num_in config bw ". $speed_in ."Kbit/s queue 10Kbytes mask dst-ip 0x00000000";
         }
        else {
          #ipfw tables
          if ($#nets_arr > 5) {
             my $table_number = $user->{TI_ID};

             my $result = `$IPFW table $table_number list`;
             if ($result eq '') {
               foreach my $line (@nets_arr) {
               	  push @FW_ACTIONS, "$IPFW table $table_number add $line";
                }
              }
            push @FW_ACTIONS, "$IPFW add $fw_num_in pipe $pipe_num_in ip from $CLIENT_IP to table\\($table_number\\) $via_if_in";
           }
          else {
            push @FW_ACTIONS, "$IPFW add $fw_num_in pipe $pipe_num_in ip from $CLIENT_IP to $nets{$traf_type} $via_if_in";
           }
            push @FW_ACTIONS, "$IPFW pipe $pipe_num_in config bw ". $speed_in ."Kbit/s queue 10Kbytes";
         }
       }
      else {
        #if speed 0 (UNlime) make only allow rules
        push @FW_ACTIONS, "$IPFW add $fw_num_in allow ip from $CLIENT_IP to $nets{$traf_type} $via_if_in";      	
       }
      
      if ($speed_out > 0) {
        if ($traf_type == 0) {
            push @FW_ACTIONS, "$IPFW add $fw_num_out pipe $pipe_num_out ip from any to $CLIENT_IP $via_if_out";
            push @FW_ACTIONS, "$IPFW pipe $pipe_num_out config bw ". $speed_out ."Kbit/s queue 10Kbytes mask dst-ip 0x00000000";
         }
        else {
          #User ipfw table if more then 5 networks
          if ($#nets_arr > 5) {
             my $table_number = $user->{TI_ID};

             my $result = `$IPFW table $table_number list`;
             if ($result eq '') {
               foreach my $line (@nets_arr) {
               	  push @FW_ACTIONS, "$IPFW table $table_number add $line";
                }
              }
             push @FW_ACTIONS, "$IPFW add $fw_num_out pipe $pipe_num_out ip from table\\($table_number\\) to $CLIENT_IP $via_if_out";
           }
          else {
            push @FW_ACTIONS, "$IPFW add $fw_num_out pipe $pipe_num_out ip from $nets{$traf_type} to $CLIENT_IP $via_if_out";
           }


          push @FW_ACTIONS, "$IPFW pipe $pipe_num_out config bw ". $speed_out ."Kbit/s queue 10Kbytes";
         }
       }
     	#if speed 0 (UNlime) make only allow rules
      else {
         push @FW_ACTIONS, "$IPFW add $fw_num_out allow ip from $nets{$traf_type} to $CLIENT_IP $via_if_out";
       }


    }
    
  }

 }

#make firewall actions
foreach my $line (@FW_ACTIONS) {
  if ($debug == 1) {
    print "$line\n";	
   }	
  else {
    system("$line");
   }
}



#**********************************************************
# Manage mikrotik bandwidth
# 3 type of actions
#  up
#  down 
#  check
#**********************************************************
sub mikrotik {
	my ($attr)=@_;

  
  
my $cmd   = '';
my $proto = 'pptp';
my $nets  = '';
my $nas_host  = '';
my $nas_admin = '';
my $SSH       = '/usr/bin/ssh';


foreach my $id (keys %{ $attr->{SPEEDS} }) {  
  my $interface = "<$proto-$USER>";
  my $name = "ads-$proto-$USER";
  my $speed_in  = $attr->{SPEEDS}->{$id}->{IN};
  my $speed_out = $attr->{SPEEDS}->{$id}->{OUT};
  $cmd = '';
  
  if ($id == 0) {
    $nets = '0.0.0.0/0';
   }
  else {
    $nets =  $attr->{NETS}->[0];
   }

  if ($nets ne '' || $id == 0) {
    if ($ACTION eq 'up') {
      $cmd = "/queue tree add name name=\"$name\" dst-address=0.0.0.0/0 interface=$interface
        parent=none direction=both priority=8 queue=default-small/default-small
        limit-at=$speed_in/$speed_out max-limit=$speed_in/$speed_out
        total-queue=default-small;";
     }
    elsif($ACTION eq 'down') {
      $cmd = "/queue tree add name remove [ find name=$name ];";
     }
   }

 }


  my $result = `$SSH $nas_admin\@$nas_host "$cmd"`;
}

#**********************************************************
# Manage mikrotik bandwidth
# 3 type of actions
#  up
#  down 
#  check
#**********************************************************
sub mikrotik_ext {
	my ($attr)=@_;


  my $argv = parse_arguments(\@ARGV);
	
	my $speeds    = $attr->{SPEEDS};
	my $nets      = $attr->{NETS};

  my $proto     = $argv->{PROTO} || 'pptp';
  my $nas_host  = $argv->{NAS_HOST} || '';
  my $nas_admin = $argv->{NAS_ADMIN}|| 'admin';
  my $SSH       = $argv->{SSH_CMD}  || '/usr/bin/ssh';

	my @commands  = ();

  $INTERFACE="<$proto-$USER>";

  if($ACTION eq 'down') {
    push  @commands,  "/queue tree add name remove [ find name=$INTERFACE ];";
   }
  else {

  foreach my $traf_type (sort keys %$speeds) {
    my $speed = $speeds->{$traf_type};
    
    my $speed_in  = (defined($speed->{IN}))  ? $speed->{IN} * 1024 : 0;
    my $speed_out = (defined($speed->{OUT})) ? $speed->{OUT}* 1024 : 0;
    if ($traf_type == 0) {
      #Upload
      push  @commands, " /queue simple add direction=upload name=\\\"". $INTERFACE.'_OUT'. "\\\" dst-address=0.0.0.0/0 interface=$INTERFACE parent=none priority=8 queue=default-small/default-small limit-at=$speed_out max-limit=$speed_out total-queue=default-small ";
      #Download
      push  @commands, " /queue simple add direction=download name=\\\"". $INTERFACE.'_IN'. "\\\" dst-address=0.0.0.0/0 interface=$INTERFACE parent=none priority=8 queue=default-small/default-small limit-at=$speed_in max-limit=$speed_in total-queue=default-small ";
      next;
     }


 	  my @nets_arr = ();
 	  if ($nets->{$traf_type}) {
 	    $nets->{$traf_type} =~ s/[\r]?\n//g;
 	    $nets->{$traf_type} =~ s/;/,/g;
 	    @nets_arr = split(/;|,/, $nets->{$traf_type});
	   }

    # Describe  / $address / speed (IN / OUT)
    # Make address list
    my $address_list_name = "TT_$user->{TP_ID}_".$traf_type;

    foreach my $address (@nets_arr) {
   	  push @commands, qq{ /ip firewall address-list add list=$address_list_name address=$address };
     }

    # Make marks
    my $mark_name=$address_list_name. "_mark";
    my $mark_name_in=$address_list_name. "_mark_in";
    my $priority = 5 - $traf_type;

    push @commands,  qq{ /ip firewall mangle add address-list=$address_list_name action=mark-connection new-connection-mark=$mark_name chain=prerouting comment=$mark_name };

    push @commands,  qq{ /queue tree add name=$mark_name parent=$INTERFACE max-limit=$speed_in/$speed_out packet-mark=$mark_name priority=8 };
    
    # Second way 
    
    # /ip firewall mangle add chain=prerouting dst-address=195.222.70.250 action=mark-onnection new-connection-mark=cybernet-connection-up passthrough=yes

    # /ip firewall mangle add chain=forward connection-mark=cybernet-connection-up ction=mark-packet new-packet-mark=cybernet-packet-up passthrough=yes

    #/ip firewall mangle add chain=prerouting src-address=195.222.70.250 action=mark-connection new-connection-mark=cybernet-connection-from passthrough=yes

    #/ip firewall mangle add chain=forward connection-mark=cybernet-connection-from action=mark-packet new-packet-mark=cybernet-packet-from passthrough=yes 
    
    #/queue tree add name="queue_$traf_type" parent=global-out packet-mark=$mark_name imit-at=0 queue=default priority=$priority max-limit=$speed_out burst-limit=0 burst-threshold=0  burst-time=0s

    #/queue tree add name="queue_$traf_type" parent=global-in packet-mark=$mark_name_in limit-at=0 queue=default priority=$priority max-limit=$speed_in burst-limit=0 burst-threshold=0s burst-time=0s 

  }
}


#Make ssh command	
	my $result = '';
	foreach my $cmd (@commands)  {
		print "$cmd\n" if ($debug > 0);
    $result .= `$SSH $nas_admin\@$nas_host "$cmd"`;
	 }

  print $result;
}



#
# get user info 
# /queue simple print interface=<pptp-aa1>
# /queue simple remove [ find  interface=<pptp-aa1> ]

#*****************************************************
# Parse fw params
#*****************************************************
sub parse_fw {
  my ($part) = @_;
  my $result = '';
  my %params = ();

  $part =~ s/"|//g;
  if ($part =~ / (\d+)/) {
    $params{item} = $1;
   }

  while($part =~ / ([a-zA-Z\-]+)=([a-zA-Z\-\.0-9\/<>_]+)/g) {
    my $key = $1;
    my $val = $2;
    $result .= "$key // $val\n";
    $params{"$key"}=$val;
   }

  print "\n---\n". $result if ($debug > 0);

  return \%params;
}
