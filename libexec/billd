#!/usr/bin/perl -w
# Accounting controll deamon
# Speed control
# Work only with Dv module
#


use vars  qw(%RAD %conf @MODULES $db $DATE $GZIP $MYSQLDUMP %ADMIN_REPORT $IPFW
 $IFCONFIG
 @START_FW
 $SNMPWALK
 $SNMPSET

 $var_dir
 $db
 
 $base_dir
 );
use strict;

use FindBin '$Bin';
require $Bin . '/config.pl';
unshift(@INC, $Bin . "/../Abills/", $Bin . '/../', $Bin . "/../Abills/$conf{dbtype}");

require "Abills/defs.conf";
require "Abills/nas.pl";
require Abills::Base;
Abills::Base->import();
my $begin_time = check_time();

my $debug=0;
my $debug_output = '';
my $ARGV = parse_arguments(\@ARGV);
my $log_dir = $var_dir.'/log';


if (defined($ARGV->{debug})) {
  $debug=$ARGV->{debug} || 1;
  print "Debug mode $debug\n";
}
elsif(defined($ARGV->{help})){
  print "Help:
CHECK exist connections
  checkppp    - check Active ppp on FreeBSD session and disconnect unknown ip
  checkpppd   - check Active pppd on Linux session and disconnect unknown ip
  check_pptpd - chack Active PoPToP deamon on Linux
  checkmikro  - check Active ppp on Mikrotik session and disconnect unknown ip.
CHECK speed
  checkspeed       - check cure speed for user on FreeBSD NAS. Arguments NAS_IDS=xx
     SHOW_SPEED=1  - Only show current speed
  checkspeed_mikro - check cure speed for user on Mikrotik. Arguments NAS_IDS=xx
  speed_expr       - Speed Expration

CHECK connection Alive
  checklines  - Check alive connections
  -d          - deamon mode

  debug       - debug mode
  NAS_IDS=... - Make actions for NAS
\n";
  exit;
}

exit if(! $ARGV->{checkppp} && make_pid($log_dir."/billd.pid") == 1);


require Abills::SQL;
Abills::SQL->import();
require Users;
Users->import();
require Admins;
Admins->import();

my $sql = Abills::SQL->connect($conf{dbtype}, $conf{dbhost}, $conf{dbname}, $conf{dbuser}, $conf{dbpasswd});
$db = $sql->{db};
my $admin = Admins->new($db, \%conf);
$admin->info($conf{SYSTEM_ADMIN_ID}, { IP => '127.0.0.1' });

my $default_alive_interval = 120;
my $exppp_hanguplimit = 3500000000;
my $error_alive_count = $conf{ERROR_ALIVE_COUNT} || 5;


if ($admin->{errno}) {
  print "AID: $conf{SYSTEM_ADMIN_ID} [$admin->{errno}] $admin->{errstr}\n";
  exit 0;
}

my %LIST_PARAMS = ();
require Dv_Sessions;
my $sessions = Dv_Sessions->new($db, $admin, \%conf);
require Dv;
my $Dv = Dv->new($db, $admin, \%conf);
require Nas;
my $nas = Nas->new($db, \%conf);
#my %stats = ();


$LIST_PARAMS{NAS_IDS}   = $ARGV->{NAS_IDS} || undef;
$LIST_PARAMS{PAGE_ROWS} = 100000;
$LIST_PARAMS{DISABLE}   = 0;

if (defined($ARGV->{checkppp}))      { check_ppp();               }
elsif (defined($ARGV->{checkpppd}))  { check_ppp({ LINUX => 1 }); }
elsif (defined($ARGV->{checkspeed})) { check_speed();             }
elsif (defined($ARGV->{check_pptpd})){ check_pptpd();             }
elsif (defined($ARGV->{checkspeed_mikro}))   { check_speed_mikro();  }
elsif (defined($ARGV->{checkmikro})) {	check_mikro();            }
elsif (defined($ARGV->{speed_expr})) {  speed_expr();             }
else {
  check_lines();
}


 if ($begin_time > 0 && $debug > 0)  {
   Time::HiRes->import(qw(gettimeofday));
   my $end_time = gettimeofday();
   my $gen_time = $end_time - $begin_time;
   printf(" GT: %2.5f\n", $gen_time);
  }

make_pid($log_dir."/billd.pid", 'clean');

#***********************************************************
# Deamon Mode
#***********************************************************
sub deamon {
	
	
	
}

#***********************************************************
# check_lines
#***********************************************************
sub check_lines {
	require Billing;
	Billing->import();

  $sessions->{debug}=1 if ($debug > 2);

	$sessions->online( { 
		                   #%LIST_PARAMS, 
		                   ALL    => 1, 
		                   #FIELDS => [0, 1, 2, 3, 4, 5, 6, 7, 8, 26, 29] 
		                   FIELDS_NAMES => [ 'USER_NAME', 'FIO', 
                             'NAS_PORT_ID', 
                             'CLIENT_IP_NUM',
                             'DURATION', 
                             'INPUT_OCTETS',
                             'OUTPUT_OCTETS', 
                             'INPUT_OCTETS2',   
                             'OUTPUT_OCTETS2',
                             'ACCT_SESSION_ID', 
                             'UID', 
                             'JOIN_SERVICE', 
                             'LAST_ALIVE',
                             'ACCT_SESSION_TIME',
                             'DURATION_SEC',
                             'DEPOSIT',
                             'CREDIT',
                             'TP_ID' ]
		                   } );	
	
  print "==> check_lines\n" if ($debug > 1);

  #Get TP Credits
  
  require Tariffs;
  Tariffs->import();
  my $Tariffs = Tariffs->new($db, $admin);
  
  my $list = $Tariffs->list();
  my %TP_CREDITS = ();

  foreach my $line (@$list) {
  	$TP_CREDITS{$line->[0]}=$line->[15];
   }


  


	$LIST_PARAMS{NAS_IDS}=$ARGV->{NAS_IDS} if ($ARGV->{NAS_IDS});

	my $online = $sessions->{nas_sorted};
  my $nas_list = $nas->list({ %LIST_PARAMS });
  my %NAS  = ();

  require Acct;
  Acct->import();
  my $Acct = Acct->new($db, \%conf);


  my %JOIN_SERVICE_STATS = ();

  foreach my $nas_row (@$nas_list) {
    #If ipcad NAS all checks make in traff2sql 
    next if ($nas_row->[4] eq 'ipcad');
    
    my $l = $online->{$nas_row->[0]};
    print "NAS IP: $nas_row->[3]\n NAS_TYPE: $nas_row->[4]\n STATUS: $nas_row->[6]\n Alive: $nas_row->[8]/\n " if ($debug > 0);

    $NAS{NAS_ID}           = $nas_row->[0];
    $NAS{NAS_IP}           = $nas_row->[3];
    $NAS{NAS_TYPE}         = $nas_row->[4];
    $NAS{NAS_ALIVE}        = $nas_row->[8] || 0;
    $NAS{NAS_MNG_IP_PORT}  = $nas_row->[9];
    $NAS{NAS_MNG_USER}     = $nas_row->[10]; 
    $NAS{NAS_MNG_PASSWORD} = $nas_row->[11]; 
    $NAS{NAS_EXT_ACCT}     = $nas_row->[13];

    
    foreach my $line (@$l) {
    	my $user_name               = $line->[0];
    	my $nas_port_id             = $line->[2];
    	my $client_ip               = $line->[3];
    	my $duration                = $line->[4];
	    my $acct_input_octets       = $line->[5];
	    my $acct_output_octets      = $line->[6];
	    my $acct_input_octets_ext   = $line->[7];
	    my $acct_output_octets_ext  = $line->[8];
	    my $acct_session_id         = $line->[9];
      my $uid                     = $line->[10];
      my $join_service            = $line->[11];
      my $last_alive              = $line->[12];
      my $acct_session_time       = $line->[13];
      my $duration_sec            = $line->[14];
      my $deposit                 = $line->[15];
      my $credit                  = ($line->[16] > 0) ? $line->[16] : (( $line->[17] ) ? $TP_CREDITS{$line->[17]} : 0 ); 


      #hangup connaction if max ext traffic reached
      if ($acct_input_octets_ext > $exppp_hanguplimit || $acct_output_octets_ext > $exppp_hanguplimit) {
        my $ret = hangup(\%NAS, "$nas_port_id", "$nas_port_id", { ACCT_SESSION_ID      => "$acct_session_id",
        	                                                        FRAMED_IP_ADDRESS    => int2ip($client_ip),
        	                                                        ACCT_TERMINATE_CAUSE => 15,
        	                                                        UID                  => $uid
        	                                                      });

        print "Hangup '$user_name' $acct_input_octets, $acct_output_octets, $acct_input_octets_ext, $acct_output_octets_ext, Session-ID: $acct_session_id\n"; 
        next;
       }     


      #Get stats from nas servers which don't support rad Alive
      my $external_stats = get_stats(\%NAS, $nas_port_id);

      if ( $NAS{NAS_ALIVE} > 0 
           && ( $last_alive > $NAS{NAS_ALIVE} * $error_alive_count )) {


         if($last_alive > ($NAS{NAS_ALIVE} * $error_alive_count * 2) ) {
           my $ACCT_INFO = $sessions->online_info({ NAS_ID          => $nas_row->[0],
                                                    NAS_PORT        => $nas_port_id,
                                                    ACCT_SESSION_ID => $acct_session_id
                                                  });

           
           $ACCT_INFO->{INBYTE}               = $acct_input_octets;
           $ACCT_INFO->{OUTBYTE}              = $acct_output_octets;
           $ACCT_INFO->{INBYTE2}              = $acct_input_octets_ext;
           $ACCT_INFO->{OUTBYTE2}             = $acct_output_octets_ext;
           $ACCT_INFO->{ACCT_STATUS_TYPE}     = 'Stop';
           $ACCT_INFO->{ACCT_SESSION_TIME}    = $acct_session_time;
           $ACCT_INFO->{ACCT_TERMINATE_CAUSE} = 3;

           my $r = $Acct->accounting($ACCT_INFO, \%NAS);
           my $info = '';
           
           if ($debug > 0) {
           	 foreach my $k (sort keys %$ACCT_INFO) {
 	  	          $info .= sprintf("%-28s | %-30s |\n", $k, (defined($ACCT_INFO->{$k})) ? $ACCT_INFO->{$k} : '' );
	           }

             $info .= sprintf("%-28s\n", '----------------------------------------------------');

	           foreach my $k (sort keys %$Acct) {
 		           $info .= sprintf("%-28s | %-30s |\n", $k, (defined($Acct->{$k})) ? $Acct->{$k} : '' );
  	         }
            }

           if ($NAS{NAS_TYPE} eq 'ipcad') {
     	        my $ret = hangup(\%NAS, "$nas_port_id", "$line->[0]", { ACCT_SESSION_ID      => "$acct_session_id",
              	                                                      FRAMED_IP_ADDRESS    => int2ip($client_ip),
              	                                                      ACCT_TERMINATE_CAUSE => $ACCT_INFO->{ACCT_TERMINATE_CAUSE},
              	                                                      UID                  => $uid,
           	                                                      });
            }

           print "Error: Session Calculate / Login: $user_name, Last Alive: $last_alive, Session-ID: $acct_session_id\n$info"; # if ( $debug == 1 );
           next;
          }
         else {
           print "Error: Lost Alive / Login: $user_name, Last Alive: $last_alive, Session-ID: $acct_session_id\n"; # if ( $debug == 1 );
           $sessions->zap($nas_row->[0], $nas_port_id, $acct_session_id);
          }
       } 
      elsif (defined($external_stats->{error})) {
      	print "Error:  Login: $user_name, NAS-IP: $NAS{NAS_IP}, Port: $nas_port_id, Session-ID: $acct_session_id\n" if ($debug == 1);
      	$sessions->online_update({ USER_NAME       => $user_name,
      		                         ACCT_SESSION_ID => $acct_session_id,
      		                         STATUS          => 5
      		                      });
       }
      elsif (defined($external_stats->{in})) {
        $sessions->online_update({ USER_NAME       => $user_name, 
        	                         ACCT_SESSION_ID => $acct_session_id, 
        	                         %$external_stats 
        	                        });
       }
      
      
     
      # periodic check deposit stats
      if ($conf{periodic_check}) {
        my %RAD = (USER_NAME         => "$user_name",
                   SESSION_START     => time - $acct_session_time,
                   ACCT_SESSION_TIME => $duration_sec,
                   INBYTE            => $acct_input_octets,
                   OUTBYTE           => $acct_output_octets,
                   INBYTE2           => $acct_input_octets_ext,
                   OUTBYTE2          => $acct_input_octets_ext,
                   ACCT_INPUT_GIGAWORDS  => 0,
                   ACCT_OUTPUT_GIGAWORDS => 0
                   );


        # Join Service operation
        if ($join_service) {
           if (! $JOIN_SERVICE_STATS{$join_service}) {
             foreach my $line (@{ $sessions->online_join_services() }) {
               $JOIN_SERVICE_STATS{"$line->[0]"}{INBYTE} = $line->[1];
               $JOIN_SERVICE_STATS{"$line->[0]"}{OUTBYTE}= $line->[2];
             }
            }

           $RAD{INBYTE} = $JOIN_SERVICE_STATS{$join_service}{INBYTE} || 0;
           $RAD{OUTBYTE}= $JOIN_SERVICE_STATS{$join_service}{OUTBYTE} || 0;
         }


        my $Billing = Billing->new($db, \%conf);	
        my $self;



        ($self->{UID}, 
         $self->{SUM}, 
         $self->{BILL_ID}, 
         $self->{TARIF_PLAN}, 
         $self->{TIME_TARIF}, 
         $self->{TRAF_TARIF}) = $Billing->session_sum("$RAD{USER_NAME}", 
                                                       $RAD{SESSION_START}, 
                                                       $RAD{ACCT_SESSION_TIME}, 
                                                       \%RAD);

        next if ($self->{UID} < 1);
        
        print "> Login: $RAD{USER_NAME} START: $RAD{SESSION_START} DURATION: $RAD{ACCT_SESSION_TIME}\n".
         "UID: $self->{UID} SUM: $self->{SUM} BILL_ID: $self->{BILL_ID} TARIF_PLAN: $self->{TARIF_PLAN} TRAF_TARIF: $self->{TRAF_TARIF}\n" if ($debug == 1);



        if ( (defined($Billing->{PAYMENT_TYPE}) && $Billing->{PAYMENT_TYPE} == 0) 
                             && ($deposit + $credit <= $self->{SUM}) ) {


           #Neg deposit filter
           if ($Billing->{NEG_DEPOSIT_FILTER} ne '' && $deposit + $credit < 0) {
              print "Skip with neg deposit filter '$Billing->{NEG_DEPOSIT_FILTER}'\n" if ($debug > 1);
              next;
           	}

           my $ret = hangup(\%NAS, "$nas_port_id", "$user_name", { ACCT_SESSION_ID      => $acct_session_id,
           	                                                       FRAMED_IP_ADDRESS    => int2ip($client_ip),
           	                                                       ACCT_TERMINATE_CAUSE => 16,
           	                                                       UID                  => $self->{UID},
           	                                                       debug                => $debug
           	                                                      });
           print "Hanguped Login: $RAD{USER_NAME} DEPOSIT: $deposit CREDIT: $credit SESSION_SUM: $self->{SUM} SESSION_ID: $acct_session_id\n"; # if ($debug == 1);
          }
       }
     }
   }
}

#**********************************************************
# Ceck current speed for exppp
#**********************************************************
sub check_speed_mikro {		
  my ($attr)=@_;
  #Get speed
  
  
  if ($attr->{NAS_IDS}) {
  	$LIST_PARAMS{NAS_IDS}=$attr->{NAS_IDS};
   }
  
  
  my %nas_speeds         = ();
  
  $LIST_PARAMS{TYPE}    ='mikrotik';
  my $list = $nas->list({ %LIST_PARAMS });

  foreach my $line (@$list) {
    my %info_hash = ();
    my %NAS       = ();

    $debug_output .= "NAS ID: $line->[0] MNG_INFO: $line->[10]\@$line->[9]\n" if ($debug > 2);
    
    $NAS{NAS_ID}    = $line->[0];
    $NAS{NAS_IP}    = $line->[3];
    $NAS{NAS_TYPE}  = $line->[4];
    $NAS{NAS_ALIVE} = $line->[8] || 0;
    $NAS{NAS_MNG_IP_PORT}  = $line->[9];
    $NAS{NAS_MNG_USER}     = $line->[10]; 
    $NAS{NAS_MNG_PASSWORD} = $line->[11]; 
   
    if ($NAS{NAS_MNG_USER} eq '') {
    	$debug_output .= "Skiped Not defined control user NAS_ID: $NAS{NAS_ID}\n" if ($debug > 1);
    	next;
     }
   
   
   
    my ($ip, $mng_port)=split(/:/, $NAS{NAS_MNG_IP_PORT}, 2);
    my $cmds = "/usr/bin/ssh -o StrictHostKeyChecking=no -i $base_dir/Certs/id_dsa.$NAS{NAS_MNG_USER} ".
      "$NAS{NAS_MNG_USER}\@$ip  \"/queue  simple  print\" ";

    my $output = '';
    $debug_output .= $cmds."\n" if ($debug > 3);
	  open(CMD, "$cmds |") || die "Can't open '$cmds' $!";
      while (my $l = <CMD>) {
        $output .= $l;
       }   
    close(CMD)	;


    my @parts = split(/[\r]\n[\r]\n/, $output);

    # key1 interface; key2 rule number; value speed
    my %rule_speed = ();

    foreach my $part (@parts) {
      my $params = parse_fw($part);
      if ($params->{'limit-at'} && $params->{'limit-at'} =~ /(\d+)\/(\d+)/) {
        $rule_speed{$params->{'item'}}{IN}=$1;
        $rule_speed{$params->{'item'}}{OUT}=$2;
       }

      if ($debug > 5) {
        while(my($key, $val)=each %$params ) {
      	   $debug_output .= "INTERFACE: $key\n";
      	   while(my($direction, $value)=each %$val) {
      	     $debug_output .= "  $direction SPEED: $value\n";
      	    }
         }
       }
     }
   
    push @{ $nas_speeds{$NAS{NAS_ID}} }, %rule_speed;
   
    if ($debug > 4) {
      while(my($key, $val) = each %rule_speed ) {
    	  $debug_output .= "INTERFACE: $key\n";
     	  while(my($direction, $value)=each %$val) {
      	  $debug_output .= "  $direction:\t$value\n";
      	 }
       }
     }
      
  }


  print $debug_output;
  
  return \%nas_speeds;
}


#*****************************************************
# Parse fw params
#*****************************************************
sub parse_fw {
  my ($part) = @_;
  my $result = '';
  my %params = ();

  $part =~ s/\"|//g;
  if ($part =~ / (\d+)/) {
    $params{item} = $1;
   }

  while($part =~ / ([a-zA-Z\-]+)=([a-zA-Z\-\.0-9\/<>_]+)/g) {
    my $key = $1;
    my $val = $2;
    $params{"$key"}=$val;
   }

  return \%params;
}

#**********************************************************
# Ceck current speed for exppp
#**********************************************************
sub check_speed {		
	
  if (! $ARGV->{NAS_IDS}) {
    print "NAS not specify. Example:\n";
    print "# billd checkspeed NAS_IDS=8,1,5...\n";
    exit;
   }

	my %LOGINS_SPEEDS = ();


  my %rule_speed = ();
  my %pipe_rules = ();
  
	#Get ng_car speed
	if ($conf{ng_car}) {
    #Get speed from server
   
    open(PROCS, "/usr/sbin/ngctl list |") || die "Can't open file '' $!\n";
      while(<PROCS>) {
		    if (/\s+Name: (class[\d+])_([a-zA-Z_0-9]+)/) {
		      my $class = $1;
		      my $login   = $2;	
		      print "Login: $login ($class". "_$login)\n" if ($debug > 1);
		      
		      $class =~ /(\d+)$/;
		      my $class_id = $1;
		      open(SUB_NG, "/usr/sbin/ngctl msg $class". "_$login: getconf|")  || die "Can't open $!\n";
		        while(<SUB_NG>) {
		        	if(/Args:\s*{ upstream={ cbs=\d+ ebs=\d+ cir=(\d+) greenAction=\d yellowAction=\d redAction=\d mode=\d } downstream={ cbs=\d+ ebs=\d+ cir=(\d+) greenAction=\d yellowAction=\d redAction=\d mode=\d } }/) {
		        		$LOGINS_SPEEDS{$login}{$class_id}{OUT}= $1 / 1024;
		        		$LOGINS_SPEEDS{$login}{$class_id}{IN} = $2 / 1024;
		        	 }
		         }
		      close(SUB_NG);
		    }
		
		  }
	  close(PROCS);	

if ($debug > 1 || $ARGV->{SHOW_SPEED}) {

    foreach my $login ( sort keys %LOGINS_SPEEDS) {
    #while(my($login, $spees_hash) = each %LOGINS_SPEEDS) {
    	my $spees_hash = $LOGINS_SPEEDS{$login};
    	
    	
    	print "$login: \n";
    	while(my($direction, $speed) = each %$spees_hash) {
    		print "  $direction  IN: $speed->{IN} OUT: $speed->{OUT}\n";
    	 }
     }

     return 0 if(defined($ARGV->{SHOW_SPEED}));
    
    
}

    #Get speed from billing
		#return 0;
	 }
else {	
	
#----------------------------------------------------------	
# old shaper check
#----------------------------------------------------------

	$conf{JOIN_SERVICE_FW_FIRST_RULE} = 40000 if (! $conf{JOIN_SERVICE_FW_FIRST_RULE});
  #Get IPFW speed rules


	my $result = `$IPFW pipe show; $IPFW show`;
	my @rules = split(/\n/, $result);
	# key1 interface; key2 rule number; value speed
	
	my %speeds_rotations = ('Kbit' => 1,
	                        'Mbit' => 1000);
	                        
  
	#Parce all ipfw rules
	foreach my $line (@rules) {
     #Parce ipfw pipe rules
     if ($line =~ /^(\d+):\s+(\S+) (\w+)/) {
       my $speed = $2 * $speeds_rotations{$3};
     	 	 $pipe_rules{$1}=$speed;
     	  }
	 }

#====

  #debug 
  if ($debug > 0) {
    print "Show rules\n" if ($debug > 1);
    while(my($iface, $rules)=each %rule_speed) {
  	  print "Interface: $iface\n" if ($debug > 1);
  	  
  	  foreach my $line ( sort keys %$rules ) {
  	 	  # ID -> Speed
  	 	  print " $line -> $rules->{$line}\n" if ($debug == 2);
  	   }
     }
   }

}
 
 
  my $users_table_number = $conf{FW_TABLE_USERS} || 10;

  my $nets_table_number  = 2;
  
  my $out_interface  = 'em0';
  if (! $conf{ng_car}) {
  	$out_interface = `/sbin/route get 91.203.4.17 | grep interface: | awk '{ print \$2 }'`;
  }
  
  $conf{FW_DIRECTION_OUT}=$ARGV->{FW_DIRECTION_OUT} if ($ARGV->{FW_DIRECTION_OUT});
  $conf{FW_DIRECTION_IN}=$ARGV->{FW_DIRECTION_IN} if ($ARGV->{FW_DIRECTION_IN});
  
  my $via_if_in          = ($conf{FW_DIRECTION_IN}) ? $conf{FW_DIRECTION_IN} : ' out xmit '. $out_interface;
  my $via_if_out         = ($conf{FW_DIRECTION_OUT}) ? $conf{FW_DIRECTION_OUT} : ' in recv '. $out_interface;



  #Get online users                             
  $sessions->{debug}=1 if ($debug > 4);

	$sessions->online( { %LIST_PARAMS, 
		                   NAS_ID  => $ARGV->{NAS_IDS}, 
		                   #FIELDS => [0, 2, 11, 13, 29]   
		                   FIELDS_NAMES => [ 'USER_NAME', 
		                   	                 'NAS_PORT_ID', 
		                   	                 'TP_ID',
		                   	                 'SPEED',
		                   	                 'UID',
		                   	                 'JOIN_SERVICE',
		                   	                 'CLIENT_IP',
		                   	                  ]
		               } );	


	my $online = $sessions->{nas_sorted};
  my $nas_list = $nas->list({ %LIST_PARAMS  });

  #my %TP_ARR = ();
  my %USER_IFACES=();
  my %TP_HASH = ();

  my $NAS_TYPE = '';
  foreach my $nas_row (@$nas_list) {
    next if (! $online->{$nas_row->[0]});

    $NAS_TYPE = $nas_row->[4];

    my $l = $online->{$nas_row->[0]};
    foreach my $line (@$l) {
                           #IFACE : TP : SPEED  :IP
       my $tp = 0;
       my $tp_id = 0;
       if ($line->[4] > 0) {
          $Dv->info($line->[4]);
          $tp    = $Dv->{TP_ID};
          $tp_id = $Dv->{TP_NUM};
        }
       else {
         $tp = $line->[2];
        }
      
       print "$line->[0] IF:$line->[1] TP:$tp SPEED:$line->[3] JOIN: $line->[5] IP:$line->[6]\n" if ($debug > 1);
       
       
       $USER_IFACES{$line->[0]}="$line->[1]:$tp_id:$line->[3]:$line->[5]:$line->[6]";

       $TP_HASH{$tp}=1;
     }
  }

  require Billing;
  Billing->import();
  my $Billing = Billing->new($db, \%conf);
  my $user = $Billing->get_timeinfo();



  require Tariffs;
  Tariffs->import();
  my $tariffs = Tariffs->new($db, $admin);
  my %speeds = ();
  
  #foreach my $tp (keys (%TP_HASH)) {
  my $tp_list = $tariffs->list({ MODULE => 'Dv',  
  	                             #TP_ID => join(';',  keys %TP_HASH) 
  	                            });
  
  my @FW_ACTIONS = ();

  if ($ARGV->{RECONFIGURE}) {
  	print "Reconfigure: $ARGV->{RECONFIGURE}\n" if ($debug > 1);

 	  push @FW_ACTIONS, "$IPFW -q flush";
	  push @FW_ACTIONS, "$IPFW -q pipe flush";
	  push @FW_ACTIONS, "$IPFW -q table 10 flush";
	  %pipe_rules = ();
  	#push @FW_ACTIONS, "$IPFW -q table 2 flush";
   }


  #GET TP speed
  foreach my $line ( @$tp_list ) {
  	my $tp_id = $line->[18];
  	my $tp    = $line->[0];

  	print "TP: $tp ($tp_id)\n" if ($debug == 2 || $ARGV->{SHOW_SPEED});

    my ($remaining_time, $ret_attr); 

    ($user->{TIME_INTERVALS},
     $user->{INTERVAL_TIME_TARIF}, 
     $user->{INTERVAL_TRAF_TARIF}) = $Billing->time_intervals($tp_id);

    ($remaining_time, $ret_attr) = $Billing->remaining_time(0, {
    	    TIME_INTERVALS      => $user->{TIME_INTERVALS},
          INTERVAL_TIME_TARIF => $user->{INTERVAL_TIME_TARIF},
          INTERVAL_TRAF_TARIF => $user->{INTERVAL_TRAF_TARIF},
          SESSION_START       => $user->{SESSION_START},
          DAY_BEGIN           => $user->{DAY_BEGIN},
          DAY_OF_WEEK         => $user->{DAY_OF_WEEK},
          DAY_OF_YEAR         => $user->{DAY_OF_YEAR},
          REDUCTION           => 0,
          POSTPAID            => 1
         });

#    print "RT: $remaining_time\n"  if ($debug == 1);
    my %TT_IDS = %$ret_attr;


    if (keys %TT_IDS > 0) {
      #Get intervals
      while(my($k, $v)=each( %TT_IDS)) {
 	      print " INTERVAL: $k, $v\n" if ($debug == 2);
        
        if (($k eq 'TT' || $k eq 'FIRST_INTERVAL') && ! $speeds{$tp}{IN}) {
 	        my $list = $tariffs->tt_list({ TI_ID => $v });
 	        foreach my $line (@$list)  {
 	        	
 	        	my $traf_type = $line->[0];
 	        	my $pipe_rule_in  = sprintf("%.5d", $START_FW[$traf_type] + $tp_id * 20);
            my $pipe_rule_out = sprintf("%.5d", $START_FW[$traf_type] + $tp_id * 20 + 1);

 	      	  my $speed_in      = $line->[4];
 	      	  my $speed_out     = $line->[5];
             
 	      	  $speeds{$tp}{IN}{$traf_type}=$speed_in;
 	      	  $speeds{$tp}{OUT}{$traf_type}=$speed_out;
	      	  
	      	  my $dest_ip = ($traf_type == 0) ? 'any' : "table\\($nets_table_number, $traf_type\\)";
	      	  
 	      	  if ($speed_in > 0) {
            	if ($ARGV->{RECONFIGURE}) { 
 	       	  	  push @FW_ACTIONS, "$IPFW -q add $pipe_rule_in pipe $pipe_rule_in ip from table\\($users_table_number, $tp_id\\) to $dest_ip $via_if_in";
 	      	  	 }

 	      	  	if (! $pipe_rules{$pipe_rule_in} || $pipe_rules{$pipe_rule_in} != $speed_in) { 
 	      	  		
 	      	  		 #print $pipe_rules{$pipe_rule_in} || $pipe_rules{$pipe_rule_in} != $speed_in;
 	      	  		
   	      	  	 push @FW_ACTIONS, "$IPFW pipe $pipe_rule_in config bw ". $speed_in ."Kbit/s queue ". (( $speed_in / 10 > 1000) ? 1000 : int( $speed_in / 10 ) ) ."Kbytes mask src-ip 0xfffffffff";
 	      	  	   print "Change TP: $tp IN: ". ( ($pipe_rules{$pipe_rule_in}) ? $pipe_rules{$pipe_rule_in} : 'Not set'  ) ." -> $speed_in\n";
           	  	 delete $pipe_rules{$pipe_rule_in};
           	   }
 	      	   }
            else{
            	if ($ARGV->{RECONFIGURE}) {
                push @FW_ACTIONS, "$IPFW add $pipe_rule_in allow ip from table\\($users_table_number, $tp_id\\) to $dest_ip $via_if_in";
               }
             }

 	      	  if ($speed_out > 0) {
             	if ($ARGV->{RECONFIGURE}) {
  	      	  	 push @FW_ACTIONS, "$IPFW -q add $pipe_rule_out pipe $pipe_rule_out ip from $dest_ip to table\\($users_table_number, $tp_id\\) $via_if_out";
               }

      	      if (! $pipe_rules{$pipe_rule_out} || $pipe_rules{$pipe_rule_out} != $speed_out) {
                 push @FW_ACTIONS, "$IPFW pipe $pipe_rule_out config bw ". $speed_out ."Kbit/s queue ". (( $speed_in / 10 > 1000) ? 1000 : int( $speed_in / 10 ) ) ."Kbytes mask dst-ip 0xffffffff";
             
                 print "Change TP: $tp OUT: ". ( ($pipe_rules{$pipe_rule_out}) ? $pipe_rules{$pipe_rule_out} : 'Not set'  ) ." -> $speed_out\n";
                 delete $pipe_rules{$pipe_rule_out};
               }
 	      	   }
            else{
            	if ($ARGV->{RECONFIGURE}) {
                push @FW_ACTIONS, "$IPFW add $pipe_rule_out allow ip from $dest_ip to table\\($users_table_number, $tp_id\\) $via_if_out";
               }
             }

            print "  Traffic Class: $traf_type IN: $line->[4] OUT: $line->[5] Pipe: $pipe_rule_in / $pipe_rule_out \n" if ($debug == 2 || $ARGV->{SHOW_SPEED});
   	      }
         }
      }
    }
   }


  if($ARGV->{SHOW_SPEED}) {
  	 return 0;
   }


  my $debug_outputs = '';
  my $cmd_debug='';

  if ($debug > 1) {
  	$cmd_debug='debug';
   }



#----------------------------------------------------------
# New NG car methods
if ($conf{ng_car})   {
  while(my($user, $other)=each %USER_IFACES) {
  	 my($IFACE, $TP, $SPEED, $JOIN_SERVICE, $IP)=split(/:/, $other);

  	 $debug_outputs = "$user -> IFACE: $IFACE TP: $TP IP: $IP SPEED: $SPEED JOIN SERVICE: $JOIN_SERVICE\n";



     if ($JOIN_SERVICE > 0) {

      }
     #No shaper definition
     elsif (! $LOGINS_SPEEDS{$user}) {
        $debug_outputs .= "  ! Speed not defined\n";	
        print $debug_outputs if ($debug > 0); 

        $debug_outputs .= check_speed_change($user, $IFACE, $IP, { 
                  	NAS_TYPE => $NAS_TYPE,
                  	debug    => ( $debug > 1) ? ' debug' : undef 
                  	});

        next;
      }
     
     #User base speed
     if ($SPEED > 0)  {
     	  $debug_outputs .= " IN:  0, $SPEED ng_car: $LOGINS_SPEEDS{$user}{0}{IN}\n".
     	                    " OUT: 0, $SPEED ng_car: $LOGINS_SPEEDS{$user}{0}{OUT}\n";
        
     	
      	if ($JOIN_SERVICE > 0) {
          if ($SPEED != $LOGINS_SPEEDS{$user}{0}{IN} || $SPEED != $LOGINS_SPEEDS{$user}{0}{OUT}) {
            $debug_outputs .= check_speed_change($user, $IFACE, $IP, { 
            	 NAS_TYPE => $NAS_TYPE,
            	 debug    => ( $debug > 1) ? ' debug' : undef 
           	 });
            }
      	  
          next;
     	   }
     	  elsif ($SPEED != $LOGINS_SPEEDS{$user}{0}{IN} || $SPEED != $LOGINS_SPEEDS{$user}{0}{OUT} ) {
           $debug_outputs .= check_speed_change($user, $IFACE, $IP, { 
           	 NAS_TYPE => $NAS_TYPE,
           	 debug    => ( $debug > 1) ? ' debug' : undef 
           	 });
           next;
     	   }

     	} 
   #TP SPEED
   	 elsif(defined($speeds{$TP})) {
  	 	 $debug_outputs .= " IN:  ";

      	if ($JOIN_SERVICE > 0) {
          if (! $LOGINS_SPEEDS{$user}{0}{IN} ||  
              ! $LOGINS_SPEEDS{$user}{0}{OUT} || 
              ! defined($speeds{$TP}{IN}{0}) || 
              ! defined($speeds{$TP}{OUT}{0}) ||
              int($LOGINS_SPEEDS{$user}{0}{IN}) != $speeds{$TP}{IN}{0} || 
              int($LOGINS_SPEEDS{$user}{0}{OUT}) != $speeds{$TP}{OUT}{0} 
             ) {
            $debug_outputs .= check_speed_change($user, $IFACE, $IP, { 
            	 NAS_TYPE => $NAS_TYPE,
            	 debug    => ( $debug > 1) ? ' debug' : undef 
           	 });
            }
          next;
     	   }


#IN SPEED
             # Class, $speed
             
          if ($speeds{$TP}){
  	 	       while(my($class_id, $v)=each %{ $speeds{$TP}{IN} }) {
  	 	       	  $debug_outputs .= "  $class_id, $v ng_car: $LOGINS_SPEEDS{$user}{$class_id}{IN}";
  	 	       	  next if (! $v);
  	 	       	  
  	 	       	  if (! $LOGINS_SPEEDS{$user}{$class_id}{IN} || $LOGINS_SPEEDS{$user}{$class_id}{IN} != $v) {
                  $debug_outputs .= check_speed_change($user, $IFACE, $IP, { 
                  	 NAS_TYPE => $NAS_TYPE,
                  	 debug    => ( $debug > 1) ? ' debug' : undef });
                  #goto ENDWHILE;
                  next;
  	 	           }
              }
           }

   	 	 $debug_outputs .= " OUT: ";
  	 	       while(my($class_id, $v)=each %{ $speeds{$TP}{OUT} }) {
  	 	       	  $debug_outputs .= "  $class_id, $v ng_car: $LOGINS_SPEEDS{$user}{$class_id}{IN}";
                next if (! $v);
  	 	       	  if (! $LOGINS_SPEEDS{$user}{$class_id}{OUT} || $LOGINS_SPEEDS{$user}{$class_id}{OUT} != $v) {
                   $debug_outputs .= check_speed_change($user, $IFACE, $IP, { 
                    	NAS_TYPE => $NAS_TYPE,
                    	debug    => ( $debug > 1) ? ' debug' : undef });
                   next;
  	 	       	   }
  	 	        }
 	  }

 


 }

}


#----------------------------------------------------------
#Old dummy net methods
else { 

  my @static_speeds = ();

  my $list = $Dv->list({ SPEED     => '>0', 
  	                     PAGE_ROWS => 100000,
  	                     SORT      => 7,
  	                     GROUP_BY  => 'dv.speed' });
  
  my $static_speed_fw_num = 50000;
  foreach my $line (@$list) {
  	my $speed = $line->[6];
  	
   	if ($ARGV->{RECONFIGURE}) {
  	  push @FW_ACTIONS, "$IPFW add $static_speed_fw_num pipe $static_speed_fw_num ip from table\\($users_table_number, 1$speed\\) to any $via_if_in";
  	 }
 	      	  	
 	  if (! $pipe_rules{$static_speed_fw_num} || $pipe_rules{$static_speed_fw_num} != $speed) { 
   	    push @FW_ACTIONS, "$IPFW pipe $static_speed_fw_num config bw ". $speed ."Kbit/s queue ". (( $speed / 10 > 1000) ? 1000 : int( $speed / 10 ) ) ."Kbytes mask src-ip 0xfffffffff";
 	      print "Change Static Speed IN: ". (($pipe_rules{$static_speed_fw_num}) ? $pipe_rules{$static_speed_fw_num} : 'Not set' ) ." -> $speed\n";
        delete $pipe_rules{$static_speed_fw_num};
      }  
    $static_speed_fw_num++;
    
   	if ($ARGV->{RECONFIGURE}) {
      push @FW_ACTIONS, "$IPFW add $static_speed_fw_num pipe $static_speed_fw_num ip from any to table\\($users_table_number, 1$speed\\) $via_if_out";
     }

 	  if (! $pipe_rules{$static_speed_fw_num} || $pipe_rules{$static_speed_fw_num} != $speed) {
        push @FW_ACTIONS, "$IPFW pipe $static_speed_fw_num config bw ". $speed ."Kbit/s queue ". (( $speed / 10 > 1000) ? 1000 : int( $speed / 10 ) ) ."Kbytes mask dst-ip 0xffffffff";
             
        print "Change Static Speed OUT: ". (($pipe_rules{$static_speed_fw_num}) ? $pipe_rules{$static_speed_fw_num} : 'Not set' ) ." -> $speed\n";
        delete $pipe_rules{$static_speed_fw_num};
     }
    $static_speed_fw_num++;
   }


 #Make speed 




  while(my($user, $other)=each %USER_IFACES) {
  	 my($IFACE, $TP, $SPEED, $JOIN_SERVICE, $IP)=split(/:/, $other);

     if ($ARGV->{RECONFIGURE}) {
     	  if ($SPEED > 0) {
     	    push @FW_ACTIONS, "$IPFW table 10 add $IP 1$SPEED";
     	   }
     	  else {
     	    push @FW_ACTIONS, "$IPFW table 10 add $IP $TP";
     	   }
      }

     next;
  	 $debug_outputs = "$user -> IFACE: $IFACE TP: $TP IP: $IP SPEED: $SPEED JOIN SERVICE: $JOIN_SERVICE\n";

     if ($JOIN_SERVICE > 0) {

      }
     #No shaper definition
     elsif (! $rule_speed{$IFACE}) {
        $debug_outputs .= "  ! No interface\n";	
        print $debug_outputs if ($debug > 0); 

        $debug_outputs .= check_speed_change($user, $IFACE, $IP, { 
                  	NAS_TYPE => $NAS_TYPE,
                  	debug    => ( $debug > 1) ? ' debug' : undef 
                  	});

        next;
      }

  	 
     if ($SPEED > 0)  {
     	  my $fw_num = $START_FW[0] + $IFACE * 2;
     	  $debug_outputs .= " IN:  0, $SPEED ipfw: $fw_num / $rule_speed{$IFACE}{$fw_num}\n".
     	                    " OUT: 0, $SPEED ipfw: ". $rule_speed{$IFACE}{$fw_num + 1} ."\n";
        
     	
      	if ($JOIN_SERVICE > 0) {
      	  my $pipe_in = $conf{JOIN_SERVICE_FW_FIRST_RULE} + $JOIN_SERVICE * 2 + 0 * 2;
      	  my $pipe_out = $conf{JOIN_SERVICE_FW_FIRST_RULE} + $JOIN_SERVICE * 2 + 0 * 2 + 1;
 
          if ($pipe_rules{$pipe_in} != $SPEED || $pipe_rules{$pipe_out} != $SPEED) {
            $debug_outputs .= check_speed_change($user, $IFACE, $IP, { 
            	 NAS_TYPE => $NAS_TYPE,
            	 debug    => ( $debug > 1) ? ' debug' : undef 
           	 });
            }
      	  
          next;
     	   }
     	  elsif ($SPEED != $rule_speed{$IFACE}{$fw_num} || $SPEED != $rule_speed{$IFACE}{$fw_num + 1} ) {
           $debug_outputs .= check_speed_change($user, $IFACE, $IP, { 
           	 NAS_TYPE => $NAS_TYPE,
           	 debug    => ( $debug > 1) ? ' debug' : undef 
           	 });
           next;
     	   }

     	}
  	 elsif(defined($speeds{$TP})) {
  	 	 $debug_outputs .= " IN:  ";

      	if ($JOIN_SERVICE > 0) {
      	  my $pipe_in = $conf{JOIN_SERVICE_FW_FIRST_RULE} + $JOIN_SERVICE * 2 + 0 * 2;
      	  my $pipe_out = $conf{JOIN_SERVICE_FW_FIRST_RULE} + $JOIN_SERVICE * 2 + 0 * 2 + 1;
 
          if (! $pipe_rules{$pipe_in} ||  ! $pipe_rules{$pipe_out} || $pipe_rules{$pipe_in} != $speeds{$TP}{IN}{0} || int($pipe_rules{$pipe_out}) != $speeds{$TP}{OUT}{0}) {
            $debug_outputs .= check_speed_change($user, $IFACE, $IP, { 
            	 NAS_TYPE => $NAS_TYPE,
            	 debug    => ( $debug > 1) ? ' debug' : undef 
           	 });
            }
          next;
     	   }


#IN SPEED
             # Class, $speed
  	 	       while(my($k, $v)=each %{ $speeds{$TP}{IN} }) {
  	 	       	  next if ($v == 0);
  	 	       	  my $fw_num = $START_FW[$k] + $IFACE * 2;
  	 	       	  $debug_outputs .= "  $k, $v ipfw: $fw_num";
  	 	       	  if (! $rule_speed{$IFACE}{$fw_num}) {
                  $debug_outputs .= check_speed_change($user, $IFACE, $IP, { 
                  	 NAS_TYPE => $NAS_TYPE,
                  	 debug    => ( $debug > 1) ? ' debug' : undef });
                  goto ENDWHILE;
                  next;
  	 	       	   }
  	 	       	  else {
  	 	       	    $debug_outputs .= "/ $rule_speed{$IFACE}{$fw_num}\n";
     	            
     	            if ($rule_speed{$IFACE}{$fw_num} != $v) {
                    $debug_outputs .= check_speed_change($user, $IFACE, $IP, { 
                    	NAS_TYPE => $NAS_TYPE,
                    	debug    => ( $debug > 1) ? ' debug' : undef });
                    goto ENDWHILE;
                    next;
     	             }
                 }
  	 	        }

   	 	 $debug_outputs .= " OUT: ";
  	 	       while(my($k, $v)=each %{ $speeds{$TP}{OUT} }) {
  	 	       	  next if ($v == 0);
  	 	       	  my $fw_num = $START_FW[$k] + $IFACE * 2 + 1 ;
  	 	       	  $debug_outputs .= "  $k, $v ipfw: $fw_num";

  	 	       	  if (! defined($rule_speed{$IFACE}{$fw_num})) {
                   $debug_outputs .= check_speed_change($user, $IFACE, $IP, { 
                    	NAS_TYPE => $NAS_TYPE,
                    	debug    => ( $debug > 1) ? ' debug' : undef });
                   next;
  	 	       	   }
  	 	       	  else {
  	 	       	    $debug_outputs .= "/ $rule_speed{$IFACE}{$fw_num}\n";
     	            
     	            if ($rule_speed{$IFACE}{$fw_num} != $v) {
                    $debug_outputs .= check_speed_change($user, $IFACE, $IP, { 
                    	 NAS_TYPE => $NAS_TYPE,
                    	 debug => ( $debug > 1) ? ' debug' : undef });
                    next;
     	             }
    	 	       	 }
  	 	        }

  	  }
  	 else {
  	 	 $debug_outputs .= " IN:  N/S (TP: $TP)\n";
  	  }

  	 ENDWHILE:
  	 print $debug_outputs if ($debug == 2); 
   }


 foreach my $cmd (@FW_ACTIONS) {
   print $cmd."\n" if ($debug > 2);
   if ($debug < 5) {
   	 system($cmd);
    }
 }

}

}

#**********************************************************
# check Active ppp session and disconnect unknown ip
# Params 
#   IFACE_ID
#    USER_NAME
#    USER_IP
#
#    NAS_TYPE    
#    NAS_IP
#**********************************************************
sub check_speed_change {
	my ( 
	  $USER_NAME,
	  $IFACE_ID,
	  $USER_IP,

	  $attr) = @_;

	my $NAS_TYPE = ($attr->{NAS_TYPE}) ? $attr->{NAS_TYPE} : '';
  my $cmd_debug = ($attr->{debug}) ? 'debug' : '';
  
  my $cmds = "$Bin/linkupdown down tun$IFACE_ID $USER_NAME $USER_IP $cmd_debug;".
             "$Bin/linkupdown up tun$IFACE_ID $USER_NAME $USER_IP $cmd_debug";

  if ($NAS_TYPE =~ /mpd/) {
     $cmds = "$Bin/linkupdown mpd down ng$IFACE_ID proto 0.0.0.0 $USER_IP $USER_NAME $cmd_debug;".
             "$Bin/linkupdown mpd up ng$IFACE_ID proto 0.0.0.0 $USER_IP $USER_NAME $cmd_debug;";
   }

  my $cmd=`$cmds`;
	
	
	return $cmd;
}


#**********************************************************
# Check Active pptpd deamons
# Kill All pptpd without parent
#**********************************************************
sub check_pptpd {
  my ($attr) = @_;
  
  #my $ps = 'ps axj | grep pp';
  my $ps = 'ps axj';
  my %procs_hash = ();
  open(PROCS, "$ps |") || die "Can't open file '$ps' $!\n";
    while(<PROCS>) {
      #LINUX
    	if (/^(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\d+)\s+(\S+)\s+(.+)/) {
    	  $procs_hash{$2}{$1}="$10";
    	  print "$2 - $3 / $10his	\n";
    	 }
    	#FreeBSD
    	#USER   PID  PPID  PGID   SID JOBC STAT  TT       TIME COMMAND
    	elsif (/^(\S+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\d+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(.+)$/) {
    	  $procs_hash{$2}{$3}="$10";
    	  print "$2 - $3 / $10his	\n";
       }
     
     }
  close(PROCS);

  while(my($pid, $sec_hash)=each %procs_hash) {
  	print "PID: $pid\n";
  	while(my($ppid, $name)= each %$sec_hash) {
  		 print "   $ppid\n";
  		 if (! defined($procs_hash{$ppid})) {
  		 	  print "Can't find parent PID: $pid PPID: $ppid NAME: $name\n";
  		 	  # my $res = `/bin/kill -9 $pid;`;
  		  }
  	 }
   }

}

#**********************************************************
# check Active FreeBSD ppp session and disconnect unknown ip
#**********************************************************
sub check_ppp {
  my ($attr) = @_;
  my $ip_pid_hash = get_if_info($attr);
  get_db_info($ip_pid_hash);


while(my($ip_address, $info)=each %$ip_pid_hash) {
  my($pid, $iface)=split(/:/, $info, 2);
  if ($conf{DV_PPP_UNCHECKED}) {
    next if ($ip_address =~ /$conf{DV_PPP_UNCHECKED}/);
   }
  
  my $res = '';  
  if ($pid > 0) {
    $res = `/bin/kill -9 $pid; /sbin/ifconfig tun$iface delete down`;
    # /sbin/ifconfig tun$iface delete
   }
  else {
    $res = `/sbin/ifconfig tun$iface delete down`;
   }

  print "Killed IP: $ip_address PID: '$pid' -- $res\n";  

  get_pid_info($pid) if -f "/var/log/ppp.log";
}

}

#**********************************************************
#Get ipaddreses of active sessions
#**********************************************************
sub get_db_info {
 my ($ip_pid_hash) = @_;
 my $list = $sessions->online({ FIELDS => [3] });	
 foreach my $line (@$list) {
   delete $ip_pid_hash->{int2ip("$line->[0]")};
  }
}


#**********************************************************
#Get pid info
#**********************************************************
sub get_pid_info {
 my ($pid, $attr) = @_;
 my $log_file='/var/log/ppp.log';

 print "\nShow log file info:\n";
 open(FILE, "<$log_file") || die "Can't open log file '$log_file' $! " ;
   while(<FILE>) {
     if (/\[$pid\]/) {
       print $_;
      }
    }
 close(FILE);
}

#**********************************************************
# Get tun interface info
#**********************************************************
sub get_if_info {
 my ($attr)   =  shift;
 my $res      = '';
 my $count    = 0;
 my $ifconfig = '';

 my %ip_pid_hash = ();

#For linux
if ($attr->{LINUX}) {
  open (IFC, "/sbin/ip addr list |") || die "Can't open file '/sbin/ip addr list' $!"; 
    while (my $l = <IFC>) { 
      if($l =~ /inet (\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3}) peer (\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3})\/\d+ scope global ppp(\d+)$/gi) { 
        my $tunnum = $3; 
        my $pid    = 0; 
        my $addr   = $2; 

        $pid = `cat /var/run/ppp$3.pid`; 
        chomp($pid); 

        print "$tunnum $addr $pid\n" if ($debug > 0); 
        $ip_pid_hash{"$addr"}="$pid:$tunnum"; 
      } 
     }
  close(IFC); 
 }
#For FreeBSD
else {
  open (IFC, "$IFCONFIG |") || die "Can't open file '$IFCONFIG' $!";
    while (my $l = <IFC>) {
      $ifconfig .= $l;
     }
  close(IFC);

#  while($ifconfig =~ /tun(\d+): (.+\n\s.+\n\s.*[\n\sa-zA-Z0-9]+\n)/gi) {
  while($ifconfig =~ /tun(\d+): (.+\n\s.+[\n\s.]+[\n\sa-zA-Z0-9]+\n)/gi) {
  
    my $tunnum = $1;
    my $res    = $2;

    my $pid    = 0;
    my $addr   = '0.0.0.0';

    my @ifs = split(/\n/, $res);

    foreach my $line (@ifs) {
      print $tunnum.'-'.$line."\n" if ($debug > 1);
      if ($line =~ /^(\d+)/) {
         $tunnum=$1;
        }
      elsif ($line =~ m/\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3} --> (\d{1,3}.\d{1,3}.\d{1,3}.\d{1,3})/g) {
         $addr = $1;
        }
      elsif ($line =~ /PID (\d+)/gi) {
         $pid = $1;
         #chomp($pid);
         #chop($pid);
       }
     }

    if ($addr eq '0.0.0.0') {
      next;
     }
    else {  
      $ip_pid_hash{"$addr"}="$pid:$tunnum";
     }
    print "$tunnum $addr $pid\n" if ($debug > 0);
   }
 }

  return \%ip_pid_hash;
}

#**********************************************************
#
#**********************************************************
sub check_mikro {
  my ($attr) = @_;	
	
  $LIST_PARAMS{TYPE}    ='mikrotik';
  my $list = $nas->list({ %LIST_PARAMS });

  foreach my $line (@$list) {
    my %info_hash = ();
    my %NAS       = ();

    $debug_output .= "NAS ID: $line->[0] MNG_INFO: $line->[10]\@$line->[9] $line->[12]\n" if ($debug > 2);
    
    $NAS{NAS_ID}    = $line->[0];
    $NAS{NAS_IP}    = $line->[3];
    $NAS{NAS_TYPE}  = $line->[4];
    $NAS{NAS_ALIVE} = $line->[8] || 0;
    $NAS{NAS_MNG_IP_PORT}  = $line->[9];
    $NAS{NAS_MNG_USER}     = $line->[10]; 
    $NAS{NAS_MNG_PASSWORD} = $line->[11]; 
   
    if ($NAS{NAS_MNG_USER} eq '') {
    	$debug_output .= "Skiped Not defined control user NAS_ID: $NAS{NAS_ID}\n" if ($debug > 1);
    	next;
     }
   
   
   
    my ($ip, $mng_port)=split(/:/, $NAS{NAS_MNG_IP_PORT}, 2);
    my $cmds = "/usr/bin/ssh -o StrictHostKeyChecking=no -i $base_dir/Certs/id_dsa.$NAS{NAS_MNG_USER} ".
      "$NAS{NAS_MNG_USER}\@$ip  \"/ppp active print\" ";

    my $output = '';
	  open(CMD, "$cmds |") || die "Can't open '$cmds' $!";
      while (my $l = <CMD>) {
        $output .= $l;
       }   
    close(CMD)	;

    $debug_output .= $cmds if ($debug > 3);
    #$debug_output .= $output if ($debug > 3);

    #Analize MK otput
    #
    #   NAME         SERVICE CALLER-ID         ADDRESS         UPTIME   ENCODING
    #0 R test         pptp    192.168.202.4     10.0.0.10       28m7s    MPPE128...

    my @rows = split(/\n/, $output);
    foreach my $line (@rows) {
    	if ($line =~ /(\d+) (\S) (\S+)\s+(\S+)\s+(\S+)\s+(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})\s+/) {
    		my $iface     = $1;
    		my $state     = $2;
    		my $username  = $3;
    		my $service   = $4;
    		my $cid       = $5;
    		my $ip        = $6;
		
    		$info_hash{$ip}=$username;
    		
    		print "IF: $iface:$state USERNAME: $username SERVICE: $service CID: $cid IP: $ip\n" if ($debug > 2);
    	 }
     }
  
    get_db_info(\%info_hash);
    
    while(my($ip, $user) = each %info_hash) {
    	print "$ip, $user\n" if ($debug > 1);

      my $ret = hangup(\%NAS, "0", "$user", { ACCT_SESSION_ID   => "",
        	                                    FRAMED_IP_ADDRESS => $ip
        	                                   });

       print "Hangup '$user' IP: $ip Session-ID: \n"; 
     }
    
  }  	
	
	print $debug_output;
	
	#return \%info_hash;
}


#**********************************************************
# Check running program
#**********************************************************
sub make_pid {
  my ($pid_file, $attr) = @_;
  
  if ($attr && $attr eq 'clean') {
  	unlink($pid_file);
  	return 0;
   }
  
  if (-f $pid_file) {
  	open(PIDFILE, "$pid_file") || die "Can't open pid file '$pid_file' $!\n";
  	  my @pids = <PIDFILE>;
  	close(PIDFILE);
    
    my $pid = $pids[0];
    if(verify($pid)) {
     	print "Proccess running PID: $pid\n";
   	  return 1;
     }
   }
  
  my $traffic2sql_pid = $$;  
	open(PIDFILE, ">$pid_file") || die "Can't open pid file '$pid_file' $!\n";
	  print PIDFILE $traffic2sql_pid;
	close(PIDFILE);    
  
  return 0;
}

#**********************************************************
# Check running program
#**********************************************************
sub verify {
    my ($pid) = @_;

    return 0 if ($pid eq '');

    my $me = $$;  # = $self->{verify};

    my @ps = split m|$/|, qx/ps -fp $pid/
           || die "ps utility not available: $!";
    s/^\s+// for @ps;   # leading spaces confuse us

    no warnings;    # hate that deprecated @_ thing
    my $n = split(/\s+/, $ps[0]);
    @ps = split /\s+/, $ps[1], $n;

    return ($ps[0]) ? 1 : 0;
}


#**********************************************************
# AVG>300=SPEED:64;
#
#**********************************************************
sub speed_expr {

  if (! $ARGV->{NAS_IDS}) {
    print "NAS not specify. Example:\n";
    print "# billd checkspeed NAS_IDS=8,1,5...\n";
    exit;
   }



  $LIST_PARAMS{NAS_IDS}=$ARGV->{NAS_IDS};

  #Get Cure speed
  my $nas_speeds = check_speed_mikro({ NAS_IDS => $ARGV->{NAS_IDS} });


#Get TP speed
  require Tariffs;
  Tariffs->import();
  my $Tariffs = Tariffs->new($db, $admin);


#Get TP
  my $list = $Tariffs->list({ %LIST_PARAMS });
  
  foreach my $tp_line (@$list) {
     my $ti_list = $Tariffs->ti_list({ TP_ID => $tp_line->[18] });
     next if ($Tariffs->{TOTAL} != 1);

     foreach my $ti (@$ti_list) {

       my $tt_list = $Tariffs->tt_list({ TI_ID => $ti->[0] });
       next if ($Tariffs->{TOTAL} != 1);
       
       my %expr_hash = ();
     	 foreach my $tt ( @$tt_list ) {
     	 	 my $expression = $tt->[8];
     	 	 next if ($expression !~ /SPEED/);
         
         $expression =~ s/MONTH_TRAFFIC/TRAFFIC/g;

         $debug_output .= "TP: $tp_line->[0] TI: $ti->[0] TT: $tt->[0]\n";
         $debug_output .= "  Expr: $expression\n" if ($debug > 3);
         
         $expr_hash{$tt->[0]} = $expression;
         

     	  }

       next if (! defined($expr_hash{0}));



	$sessions->online( { %LIST_PARAMS, 
		                   NAS_ID  => $ARGV->{NAS_IDS}, 
		                   TP_ID   => $tp_line->[0],
		                   FIELDS_NAMES => [ 'USER_NAME', 
		                   	                 'NAS_PORT_ID', 
		                   	                 'TP_ID',
		                   	                 'SPEED',
		                   	                 'UID',
		                   	                 'JOIN_SERVICE',
		                   	                 'CLIENT_IP',
		                   	                  ]
		               } );	

	my $online = $sessions->{nas_sorted};
	
  my $nas_list = $nas->list({ %LIST_PARAMS  });

  my %USER_IFACES=();
  my %TP_HASH = ();

  my $NAS_TYPE = '';
  foreach my $nas_row (@$nas_list) {
    next if (! $online->{$nas_row->[0]});

    $NAS_TYPE = $nas_row->[4];

    my $l = $online->{$nas_row->[0]};
    foreach my $line (@$l) {
                           #IFACE : TP : SPEED  :IP
       my $tp = 0;
       my $tp_id = 0;
       if ($line->[5] > 0) {
          $Dv->info($line->[5]);
          $tp    = $Dv->{TP_ID};
          $tp_id = $Dv->{TP_NUM};
        }
       else {
         $tp = $line->[2];
        }
      
       #Get last period traffic and speed
       my $cur_speed = $sessions->detail_sum({ LOGIN => $line->[0] });
       
      
       #Set speed
       if (! $nas_speeds->{$nas_row->[0]}) {
       	  
        }
      
       print "$line->[0] IF:$line->[1] TP:$tp SPEED:$line->[3]/Download speed: $cur_speed JOIN: $line->[5] IP:$line->[6]\n" if ($debug > 1);
       
       
       $USER_IFACES{$line->[0]}="$line->[1]:$tp_id:$line->[3]:$line->[5]:$line->[6]";

       $TP_HASH{$tp}=1;
     }
  }






}

}


print $debug_output;



#GET TRAFFIC


#SET SPEED

	
	
	
}

__END__


